<!DOCTYPE html><html><head><title>Fibonacci number - DemoHut</title><link rel="stylesheet" href="/main.css"></head><body><div class="jumbotron jumbotron-fluid text-monospace" id="jumbotron"><div class="container" style="position: relative"><h1><a href="/">DemoHut</a></h1><a class="text-secondary" href="/about_me.json" target="_blank" style="position: absolute; right: 15px; bottom: 0px;">About me</a></div></div><div class="container"><form class="text-right" action="/"><button class="btn btn-outline-primary" type="submit">← all posts</button></form><div class="display-4"><p>Fibonacci number</p></div><div id="content"><style type="text/css">.snippet {
    color: #f0f0f0;
    background-color: #404040
}
</style><p>How can we solve Fibonacci number as fast as possible?</p><pre class="alert-info">- Code examples here are written in Python.
</pre><div class="sub-title">Recursion</div><p>The most natural way to do this is using recursive function calls:</p><pre class="snippet">def fib(x):
    if x == 0:
        return 0
    elif x == 1:
        return 1
    else:
        return fib(x - 1) + fib(x - 2)
</pre><p>If we treat an addition as the basic calculation unit, we get an interesting conclusion: time complexity T(n) = O(fib(n - 1)) = O(1.618^n). Considering function call overheads in addition, this method is rather inefficient.</p><div class="sub-title">Iteration</div><p>If we simply transform the recursion to iteration, the time complexity reduces to linear T(n) = O(n):</p><pre class="snippet">def fib(x):
    a = 0
    b = 1
    for i in range(2, x + 1):
        b = a + b
        a = b - a
    return b
</pre><p>Can it be even faster?</p><div class="sub-title">Formula</div><p>There is a general formula for Fibonacci number calculation, with which it's easy to write the code:</p><pre class="snippet">def fib(x):
    sqrt5 = 5 ** 0.5
    return int(1 / sqrt5 * (((1+sqrt5) / 2) ** x - ((1-sqrt5)/2) ** x))
</pre><p>It seems to be a O(1) solution, since pow(x, y) is of O(1) on modern CPU architectures. But if the number is too large, we have to implement the exponentiation manually. Luckily, there is a method called "exponentiation by squaring"（快速幂）, based on a divide-and-conquer strategy, that we can use to achieve O(log(n)) complexity. </p><div class="sub-title">Matrix</div><p>Can we avoid floating point calculation, while keeping the O(log(n)) time complexity? The answer is yes:</p><img src="./fib_matrix.png" width="60%"><p>To get the value of f(n), we need to perform exponentiation on the matrix, and obtain the first element of the result. With the same divide-and-conquer idea, this can be optimized to O(log(n)) as well.</p><p>Code:</p><pre class="snippet">import numpy as np

def fib(x):
    result = np.array([[0, 1], [0, 1]])
    power = np.array([[1, 1], [1, 0]])

    while (x):
        if x & 1:
            result = result.dot(power)

        x = x >> 1
        power = power.dot(power)

    return result[0][0]</pre></div><a class="text-right" href="https://github.com/ZhujinLi/ZhujinLi.github.io/tree/master/_source_code/src/subjs/subj-fib" target="_blank"><p>→ view src</p></a><div class="hr-theme-slash-2"><div class="hr-line l"></div><div class="hr-icon"><a href="https://www.cnblogs.com/xrst"><img src="/links/cnblogs.png" height="32px"></a></div><div class="hr-icon"><a href="http://jsrun.net/u/zjli"><img src="/links/jsrun.png" height="32px"></a></div><div class="hr-icon"><a href="https://github.com/ZhujinLi"><img src="/links/github.png" height="32px"></a></div><div class="hr-icon"><a href="https://www.shadertoy.com/user/zjli"><img src="/links/shadertoy.png" height="32px"></a></div><div class="hr-line r"></div></div></div><script src="/main.js" type="module"></script></body></html>