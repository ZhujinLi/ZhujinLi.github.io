<!DOCTYPE html><html><head><title>Transparent color matters - DemoHut</title><link rel="stylesheet" href="/main.css"></head><body><div class="jumbotron jumbotron-fluid text-monospace" id="jumbotron"><div class="container" style="position: relative"><h1><a href="/">DemoHut</a></h1><a class="text-secondary" href="/about_me.json" target="_blank" style="position: absolute; right: 15px; bottom: 0px;">About me</a></div></div><div class="container"><form class="text-right" action="/"><button class="btn btn-outline-primary" type="submit">← all posts</button></form><div class="display-4"><p>Transparent color matters</p></div><div id="content"><p>Consider a simple 2x2 texture consisting of two opaque red texels(1,0,0,1) and two transparent texels(0,0,0,0):</p><img src="./2x2-mag.png" width="60"><p>If we are going to magnify this 2x2 texture and map it to a larger area (say 128x128), we expect to see this (generated by Photoshop):</p><img src="./2x2-expected.png" width="200"><p>But when trying so with OpenGL (or WebGL which I'm using here), you'll get something strange instead:</p><div style="position: relative;"><canvas id="view-bad" width="200" height="200"></canvas></div><p>There are some unwanted black fringes around the red blocks. What happens there?</p><div class="sub-title">Texture filtering</div><p>In the rendering pipeline, a magnified texture is filtered in a quite straight-forward manner: simply performing a linear combination on the four neighboring texels' RGBA values, one channel at a time. For instance, in the middle between a red texel and a transparent one, the final color will be blended like this:</p><p class="text-center text-monospace">0.5*(1,0,0,1) + 0.5*(0,0,0,0) = (0.5,0,0,0.5)</p><p>Now we are clear where the black comes from—those transparent, invisible texels! Their color matters. Blending a red color and transparent ought to produce a translucent 'proper red', like (1,0,0,0.5), but the pipeline gives a translucent 'dark red' (0.5,0,0,0.5). This is wrong.</p><p>And this "black fringing" artifact is very common in real time rendering. Here's one another:</p><img src="./mush_bad.png" width="200"><p>Although some software implementations can do the filtering correctly, graphics cards generally just couldn't get it right. Fortunately, there are methods to address this problem without touching the graphics driver, among which the two most mainstream ones are:</p><div class="sub-title">Method 1: texture bleeding</div><p>Since the black comes from texels whose alpha is 0, we can simply modify the source texture and turn these texels' RGB to red, and the resulting RGB would be red anyway:</p><p class="text-center text-monospace">0.5*(1,0,0,1) + 0.5*(1,0,0,0) = (1,0,0,0.5)</p><p>Experiment with WebGL, it's working indeed:</p><div style="position: relative;"><canvas id="view-bleeding" width="200" height="200"></canvas></div><p>This process is called "bleeding", i.e., spreading the RGB of the object's solid-color texels along the edge to nearby transparent ones, while maintaining their alpha 0. This can be done with some image processing software like Photoshop. Here's a real-world example:</p><img src="./bleeding-demo.png" width="300"><p>The original icon areas are expanded by 1 texel, and these expanded texels are assigned corresponding RGB values. Here for illurstration purpose I make these texels visible, yet in reality they are fully transparent. If you are going to use the texture's mipmaps, make the bleeding range as large as possible. Otherwise a 1-texel border as the above example is sufficient.</p><div class="sub-title">Method 2: premultiplied alpha</div><p>Let's change the 2x2 texture a bit: make the two fully transparent pixels slight green (0,1,0,0.1), which is barely noticeable.</p><img src="./2x2-green.png" width="60"><p>Unsurprisingly, the GPU gives us the familiar artifact:</p><div style="position: relative;"><canvas id="view-green-bad" width="200" height="200"></canvas></div><p>Let's inspect the formula once again:</p><p class="text-center text-monospace">0.5*(1,0,0,1) + 0.5*(0,1,0,0.1) = (0.5,0.5,0,0.55)</p><p>The biggest problem here is the resulting green shares the same weight as the red channel, even if it comes from such a trivial source. It's intuitive to consider giving less weight of tinge to texels with smaller alpha. What if we multiply RGB by A, and represent the color with (RA,GA,BA,A) instead of (R,G,B,A)?</p><p class="text-center text-monospace">0.5*(1,0,0,1) + 0.5*(0,0.1,0,0.1) = (0.5,0.05,0,0.55)</p><p>Okay, now the green is significantly reduced, which is good. However, the red component seems incorrect—it should be 1 or something. Note the above representation is based on (RA,GA,BA,A), so we need to restore it to (R,G,B,A) by dividing RGB by A, which turns out to be (0.91,0.09,0,0.55). Seems right now.</p><p>This representation of (RA,GA,BA,A) is known as "premultiplied alpha", in contrast to the original "straight alpha", "unassociated alpha", "separate alpha", "unmultiplied alpha", "nonpremultiplied alpha"... whatever you call it.</p><p>To enter the premultiplied space, we need to alter the texels in PNG, or process them when reading them into memory. But how do we convert them back to straight (R,G,B,A) representation in the end?</p><p>In rendering pipeline, the final color of a pixel is to be blended with the one already in the framebuffer. The default blend function of OpenGL is (we only discuss RGB here):</p><p class="text-center text-monospace">d_RGB = (s_RGB * GL_SRC_ALPHA) + (d_RGB * GL_ONE_MINUS_SRC_ALPHA)</p><p>In premultiplied world, the color outputted from the fragment shader is (RA,GA,BA,A), which needs to be restored before blending:</p><p class="text-center text-monospace">d_RGB = (s_RGB / s_A * GL_SRC_ALPHA) + (d_RGB * GL_ONE_MINUS_SRC_ALPHA)</p><p>Which is:</p><p class="text-center text-monospace">d_RGB = (s_RGB * GL_ONE) + (d_RGB * GL_ONE_MINUS_SRC_ALPHA)</p><p>So, all we have to do is change the blend function to:</p><p class="text-center text-monospace">glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</p><p>Let's do the experiment using WebGL again:</p><div style="position: relative;"><canvas id="view-green-pma" width="200" height="200"></canvas></div><p>Perfect. Dark fringes disappeared.</p><p>All in all, the premultiplied alpha approach involves two key operations:</p><ol><li>Premultiply texels in the texture file (or loading process)</li><li>Change the rendering pipeline blend function</li></ol><div class="sub-title">Notes</div><ul><li>WebGL behaves differently from OpenGL in some aspects. For example, the canvas is composited over the HTML page assuming premultiplied alpha by default. Hence, in the demos above, I turn off the alpha channel writing mask for a clearer elaboration. See the code for details.</li><li>There are more discussions in <a href="http://www.realtimerendering.com/blog/gpus-prefer-premultiplication/" target="_blank">GPUs prefer premultiplication</a></li></ul><script src="./subj-transparent-color.js" type="module"></script></div><a class="text-right" href="https://github.com/ZhujinLi/ZhujinLi.github.io/tree/master/_source_code/src/subjs/subj-transparent-color" target="_blank"><p>→ view src</p></a><div class="hr-theme-slash-2"><div class="hr-line l"></div><div class="hr-icon"><a href="https://www.cnblogs.com/xrst"><img src="/links/cnblogs.png" height="32px"></a></div><div class="hr-icon"><a href="http://jsrun.net/u/zjli"><img src="/links/jsrun.png" height="32px"></a></div><div class="hr-icon"><a href="https://github.com/ZhujinLi"><img src="/links/github.png" height="32px"></a></div><div class="hr-icon"><a href="https://www.shadertoy.com/user/zjli"><img src="/links/shadertoy.png" height="32px"></a></div><div class="hr-line r"></div></div></div><script src="/main.js" type="module"></script></body></html>